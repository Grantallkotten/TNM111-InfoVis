<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        background-color: #363744;
        display: flex;
      }
      canvas {
        background-color: white;
        border-radius: 0.4vw;
        margin: 1vw;
        box-shadow: 0 0 1vw white; /* Horizontal offset, vertical offset, blur radius, and color */
      }
    </style>
    <title>Scatter Plot Visualization</title>
  </head>
  <body>
    <canvas id="scatterPlotCanvas"></canvas>
    <canvas
      id="legendCanvas"
      style="width: fit-content; height: fit-content"
    ></canvas>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Dictionary to store colors and shapes for each unique class
        let dictionary = [];

        // Function to read the CSV file
        function readCSV(file, callback) {
          let xhr = new XMLHttpRequest();
          xhr.onreadystatechange = function () {
            if (xhr.readyState === 4 && xhr.status === 200) {
              callback(xhr.responseText);
            }
          };
          xhr.open("GET", file, true);
          xhr.send();
        }

        // Function to parse CSV data
        function parseCSV(csvData) {
          let rows = csvData.split("\n");
          let data = [];
          let dataPoint;

          for (let i = 0; i < rows.length; i++) {
            let columns = rows[i].split(",");
            if (columns.length === 3) {
              data.push({
                x: parseFloat(columns[0]),
                y: -parseFloat(columns[1]),
                className: columns[2].trim(),
              });
            }
          }
          return data;
        }

        function getClass(className) {
          let existingClass;

          dictionary.forEach(function (element) {
            if (element.name == className) {
              existingClass = element;
            }
          });
          if (existingClass) {
            return existingClass;
          }
          let newClass = {
            color: "#" + Math.floor(Math.random() * 16777215).toString(16),
            name: className,
          };
          dictionary.push(newClass);

          return newClass;
        }

        function calculateDistance(point1, point2) {
          const dx = point1.x - point2.x;
          const dy = point1.y - point2.y;
          return Math.sqrt(dx * dx + dy * dy);
        }

        function drawScatterPlot(data) {
          console.log(data);

          // Set up the canvas element
          var canvas = document.getElementById("scatterPlotCanvas");
          var ctx = canvas.getContext("2d");

          // set canvas size to window size
          canvas.width = window.innerWidth * 0.9;
          canvas.height = window.innerWidth * 0.9;

          // Set up min and max values
          const minX =
            data
              .map((point) => point.x)
              .reduce((min, currentX) => Math.min(min, currentX), Infinity) -
            10;

          const minY =
            data
              .map((point) => point.y)
              .reduce((min, currentY) => Math.min(min, currentY), Infinity) -
            10;

          const maxX =
            data
              .map((point) => point.x)
              .reduce((max, currentX) => Math.max(max, currentX), -Infinity) +
            10;

          const maxY =
            data
              .map((point) => point.y)
              .reduce((max, currentY) => Math.max(max, currentY), -Infinity) +
            10;

          // Calculate scale and offset for the plot
          const padding = 20;
          const scaleX = (canvas.width - 2 * padding) / (maxX - minX); // What a pixel is in terms of a x-value
          const scaleY = (canvas.height - 2 * padding) / (maxY - minY); // What a pixel is in terms of a y-value

          const plotOrigin = {
            x: padding + (0 - minX) * scaleX,
            y: canvas.height - (padding + (0 - minY)) * scaleY,
          };

          // Draw x-axis
          ctx.beginPath();
          ctx.moveTo(0 + padding, 0 + padding);
          ctx.lineTo(0 + padding, canvas.height - 2 * padding);
          ctx.fillStyle = "black";
          ctx.stroke();

          for (
            let x = Math.min(Math.ceil(minX / 5) * 5, 0);
            x < Math.floor(maxX / 5) * 5;
            x += 5
          ) {
            const xPos = x;
            const yPos = 0;
            const tickSize = 6;
            if (5 < xPos - minX) {
              ctx.beginPath();
              ctx.moveTo(
                (xPos - minX) * scaleX,
                canvas.height - 2 * padding - tickSize
              );
              ctx.lineTo(
                (xPos - minX) * scaleX,
                canvas.height - 2 * padding + tickSize
              );
              ctx.fillStyle = "black";
              ctx.stroke();

              ctx.font = scaleX.toString() + "px Arial";
              ctx.textAlign = "center";
              ctx.fillText(
                xPos.toString(),
                (xPos - minX) * scaleX,
                canvas.height - 2 * padding - 20
              );
            }
          }

          // Draw y-axis
          ctx.beginPath();
          ctx.moveTo(0 + padding, canvas.width - 2 * padding);
          ctx.lineTo(canvas.width - 2 * padding, canvas.height - 2 * padding);
          ctx.strokeStyle = "black";
          ctx.stroke();

          for (
            let y = Math.min(Math.ceil(minY / 5) * 5, 0);
            y < Math.floor(maxY / 5) * 5;
            y += 5
          ) {
            const xPos = 0;
            const yPos = y;
            let tickSize = 6;

            ctx.beginPath();
            ctx.moveTo(0 + padding - tickSize, (yPos - minY) * scaleY);
            ctx.lineTo(0 + padding + tickSize, (yPos - minY) * scaleY);
            ctx.fillStyle = "black";
            ctx.stroke();

            ctx.font = scaleX.toString() + "px Arial";
            ctx.textAlign = "center";
            ctx.fillText(
              (-y).toString(),
              0 + padding + 20,
              (yPos - minY) * scaleY
            );
          }

          // Draw x = 0
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.fillStyle = "#1C355C";
          ctx.moveTo((0 - minX) * scaleX, 0 + padding);
          ctx.lineTo((0 - minX) * scaleX, canvas.height - 2 * padding);
          ctx.stroke();
          // Reset line dash to default (solid line)
          ctx.setLineDash([]);

          // Draw y = 0
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(0 + padding, (0 - minY) * scaleY);
          ctx.lineTo(canvas.width - padding, (0 - minY) * scaleY);
          ctx.stroke();
          // Reset line dash to default (solid line)
          ctx.setLineDash([]);

          // Draw data points
          data.forEach((point) => {
            ctx.beginPath();
            ctx.fillStyle = getClass(point.className).color;

            if (dictionary[0].name == point.className) {
              ctx.rect(
                (point.x - minX) * scaleX - 3,
                (point.y - minY) * scaleY - 3,
                12, // x-width
                12 // y-height
              );
            } else if (dictionary[1].name == point.className) {
              const size = 1;
              ctx.moveTo(
                (point.x - minX) * scaleX,
                (point.y - minY - size) * scaleY
              );
              ctx.lineTo(
                (point.x - minX + size) * scaleX,
                (point.y - minY + size) * scaleY
              );
              ctx.lineTo(
                (point.x - minX - size) * scaleX,
                (point.y - minY + size) * scaleY
              );
            } else {
              ctx.arc(
                (point.x - minX) * scaleX,
                (point.y - minY) * scaleY,
                6, // radius
                0, // Start ang
                2 * Math.PI // end ang
              );
            }
            ctx.fill();
            ctx.stroke();
          });

          // Draw legend
          drawLegend();
        }

        function drawPoints(points, ctx) {
          data.forEach((point) => {
            ctx.beginPath();
            ctx.fillStyle = getClass(point.className).color;

            if (dictionary[0].name == point.className) {
              ctx.rect(
                (point.x - minX) * scaleX - 3,
                (point.y - minY) * scaleY - 3,
                12, // x-width
                12 // y-height
              );
            } else if (dictionary[1].name == point.className) {
              const size = 1;
              ctx.moveTo(
                (point.x - minX) * scaleX,
                (point.y - minY - size) * scaleY
              );
              ctx.lineTo(
                (point.x - minX + size) * scaleX,
                (point.y - minY + size) * scaleY
              );
              ctx.lineTo(
                (point.x - minX - size) * scaleX,
                (point.y - minY + size) * scaleY
              );
            } else {
              ctx.arc(
                (point.x - minX) * scaleX,
                (point.y - minY) * scaleY,
                6, // radius
                0, // Start ang
                2 * Math.PI // end ang
              );
            }
            ctx.fill();
            ctx.stroke();
          });
        }

        function drawLegend() {
          var legendCanvas = document.getElementById("legendCanvas");
          var legendCtx = legendCanvas.getContext("2d");

          const legendSpacing = 30;

          let legendX = 30;
          let legendY = legendSpacing;
          const size = 24;

          dictionary.forEach((item) => {
            legendCtx.beginPath();
            legendCtx.fillStyle = item.color;

            if (item.name === dictionary[0].name) {
              legendCtx.rect(
                legendX - size / 2,
                legendY - size / 2,
                size,
                size
              );
            } else if (item.name === dictionary[1].name) {
              legendCtx.moveTo(legendX, legendY - size / 2);
              legendCtx.lineTo(legendX + size / 2, legendY + size / 2);
              legendCtx.lineTo(legendX - size / 2, legendY + size / 2);
            } else {
              legendCtx.arc(legendX, legendY, size / 2, 0, 2 * Math.PI);
            }
            legendCtx.fill();
            legendCtx.stroke();

            legendCtx.fillStyle = "black";

            legendCtx.font = size + "px Arial";
            legendCtx.textAlign = "left";
            legendCtx.fillText(item.name, legendX + 20, legendY + 5);
            legendY += legendSpacing;
          });
        }

        // Load CSV file on document load
        readCSV("data1.csv", function (csvContent) {
          let csvData = parseCSV(csvContent);
          drawScatterPlot(csvData);
        });
      });
    </script>
  </body>
</html>
